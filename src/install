#!/bin/bash

dotfiles_dir="$HOME/dotfiles"
build_path="build"
source_path="src"
config_file="config.mk"

export DEPTH=0

# Opts
export SILENT=0
export BUILD_ALL=0

error() {
    echo "Error:" $1 1>&2
    exit 1
}

set_bool_flag() {
    while true; do
        read -p "Configure $1? (y/n) " yn
        case $yn in
            [Yy]* )
                eval "$2+=('$1')"
                return 0 ;;
            [Nn]* )
                return 1 ;;
            * ) ;;
        esac
    done
}

# $1 = args
make_config() {
    local projects_out=()
    local tags_out=()
    # TODO check which packages depend on eachother
    for i in ${projects[@]}; do
        set_bool_flag $i projects_out
    done
    for i in ${tags[@]}; do
        set_bool_flag $i tags_out
    done
    echo "PROJECTS=(${projects_out[@]})" >> $config_file
    echo "TAGS=(${tags_out[@]})" >> $config_file
}

get_depth() {
    for ((i=0; i<$DEPTH; i++)) {
        echo -ne " " 
    }
    return
}

export -f get_depth

build_module() {
    let DEPTH+=1
    echo -e $(get_depth)"Building module: \e[0;31m$1\e[0m"
    ( cd $1 && ./install build )
    let DEPTH+=-1
}

build_submodule() {
    let DEPTH+=1
    echo -e "$(get_depth)Building submodule: \e[0;31m$1\e[0m"
    ( cd $1 && ./install build )
    let DEPTH+=-1
}

export -f build_submodule

# Deletes all lines between <<<{$1} and >>>{$1} including the tags in file $2
# $3 determines wether to delete the chunk or only the tags
delete_chunk() {
    if ! [ ${3} -eq 0 ]; then
        sed -i "/<<<{${1}}/,/>>>{${1}}/d" "$2"
    else
        sed -i "/<<<{${1}}/d" "$2"
        sed -i "/>>>{${1}}/d" "$2"
    fi
}

export -f delete_chunk

tag_enabled() {
    source $CONFIG
    local i
    for i in "${TAGS[@]}"; do [ "$i" == "$1" ] && return 0; done
    return 1
}

export -f tag_enabled

project_enabled() {
    source $CONFIG
    local i
    for i in "${PROJECTS[@]}"; do [[ "$i" == "$1" ]] && return 0; done
    return 1
}

export -f project_enabled

# Moves file to $BUILD_PATH and creates recipe entry
# $1 = name of file to build. Will be overwritten with path to file
# $2 = name of place to install to
# $3 = name of file once installed
build_file() {
    let DEPTH+=1
    local path=$2
    if [[ -z $path ]];then
        path="${HOME}"
    fi
    local name=$3
    if [[ -z $3 ]];then
        name=".$1"
    fi
    # if file with same name is present we handle the collision
    local build_name=$1
    local suffix=0
    while [[ -f ${BUILD_PATH}/$build_name ]]; do
        build_name=${1}.${suffix}
        # might not work
        eval "$1='${build_name}'"
        let suffix+=1
    done
    cp -i $1 ${BUILD_PATH}/${build_name}
    echo -e "$(get_depth)built $1"
    echo "$build_name $path $name" >> $RECIPE
    let DEPTH+=-1
}

export -f build_file

# $1 = arguments
build() {
    mkdir $build_path
    touch $build_path/recipe
    if ! [[ -f $config_file ]]; then
        error "Config file doesn't exist."
    fi
    source $4
    local elem
    for elem in "${PROJECTS[@]}"; do
        (cd $source_path && build_module $elem)
    done
}

# $1 = arguments
patch() {
    cat $build_path/recipe | \
    while read LINE; do
        local from=$(echo $LINE | awk '{print $1}')
        local to=$(echo $LINE | awk '{print $2}')
        local name=$(echo $LINE | awk '{print $3}')
        ( cd $BUILD_PATH && mkdir -p $to && cp $from "${to}/${name}" )
    done
}

get_dotrc() {
    if ! [[ -z $DOTRC ]]; then
        return
    fi
    # TODO don't error if file doesn't exist
    if [[ -z $XDG_CONFIG_HOME ]]; then
        if [[ -z $HOME/.config/dot/dotrc ]]; then
            DOTRC="/etc/dotrc"
        else
            DOTRC="$HOME/.config/dot/dotrc"
        fi
    else
        DOTRC="$XDG_CONFIG_HOME/dot/dotrc"
    fi
}

help() {
    cat <<HELP
usage: dot [options] command
HELP
}

main() {
    # get parameters, TODO remove last element
    args="$@"

    while getopts ":h" opt; do
        case $opt in
            h)
                help && exit 0
                ;;
            *)
                break
                ;;
        esac
    done
    # get last argument, which should be the command
    shift $((OPTIND-1))
    cmd=$1

    if [[ -z $cmd ]]; then
        help && exit 1
    fi

    # Source the config file
    get_dotrc
    dotfiles_dir=""
    source $DOTRC
    
    if [[ -z dotfiles_dir ]]; then
        dotfiles_dir="$HOME/dotfiles"
    fi
    
    cd $dotfiles_dir
    
    source ./install

    case $cmd in
        clean)
            rm -r $build_path
            ;;
        config)
            make_config $args "$config_file" "$source_path"
            ;;
        build)
            build $args "$build_path" "$source_path" "$config_file"
            ;;
        patch)
            patch "$args" "$build_path"
            ;;
        *)
            error "Invalid command" && exit 1
            ;;
    esac
}

main "$@"
